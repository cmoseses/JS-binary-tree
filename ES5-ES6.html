<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Binary tree</title>

    <script type="text/javascript">
        'use strict'
        /* strict mode:
         * 1.不使用let声明变量严格模式中将不通过
         * 2.任何使用'eval'的操作都会被禁止
         * 3.eval作用域
         * 4.with被禁用
         * 5.caller/callee 被禁用
         * 6.对禁止扩展的对象添加新属性会报错
         * 7.删除系统内置的属性会报错
         * 8.delete使用let声明的变量或挂在window上的变量报错
         * 9.delete不可删除属性(isSealed或isFrozen)的对象时报错
         * 10.对一个对象的只读属性进行赋值将报错
         * 11.对象有重名的属性将报错
         * 12.函数有重名的参数将报错
         * 13.八进制表示法被禁用
         * 14.arguments严格定义为参数，不再与形参绑定
         * 15.函数必须声明在顶层
         * 16.ES5里新增的关键字不能当做变量标示符使用，如implements, interface, let, package, private, protected, public, static, yield
         * 17.call/apply的第一个参数直接传入不包装为对象
         * 18.call/apply的第一个参数为null/undefined时，this为null/undefined
         * 19.bind的第一个参数为null/undefined时，this为null/undefined
         * */

        /* ES5
         * Iteration: forEach, map, filter, some, every
         * Object: Object.create, getPrototypeOf, defineProperty()、defineProperties()、getOwnPropertyDescriptor()、getOwnPropertyNames()、keys() , preventExtensions()、isExtensible()、seal()、isSealed()、freeze()、isFrozen()   enumerable、configurable、writable、get、set
         * Function: bind
         * Array: isArray, indexOf, lastIndexOf
         * String: trim
         * JSon
         * Date: now, prototype.toJSON()
         *
         * */


        /* ES6
         * // let, const 块级作用域
         * // 负值结构
         * let singer = { first: "Bob", last: "Dylan" };
         * let { first: f, last: l } = singer; // 相当于 f = "Bob", l = "Dylan"
         * let [all, year, month, day] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec("2015-10-25");
         * let [x, y] = [1, 2, 3]; // x = 1, y = 2
         * // Default
         * function findArtist(name='lu', age='26') {
         * ...
         * }
         * // Rest
         * function f(x, ...y) {
         * y is an Array
         * return x * y.length;
         * }
         * f(3, "hello", true) == 6
         * // Spread
         * function f(x, y, z) {
         * return x + y + z;
         * }
         * Pass each elem of array as argument
         * f(...[1,2,3]) == 6
         * // Arrow functions
         * // Template strings
         * var name = "Bob", time = "today";
         * ` ello ${name}, how are you ${time}?`
         * // Class
         * constructor、extends、super
         * // Modules
         * export
         * // Map + Set + WeakMap + WeakSet
         * // Proxies
         * // Symbols
         * // Promises
         * */
        function Node(value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }

        function Tree() {
            this.root = null;
        }

        Tree.prototype.insert = function (value) {
            let node = new Node(value);
            let current = this.root;
            if (!this.root) {
                this.root = new Node(value);
                return true;
            }
            while (current !== null) {
                if (value < current.value) {
                    if (current.left === null) {
                        current.left = node;
                        break;
                    } else {
                        current = current.left;
                    }
                } else {
                    if (current.right === null) {
                        current.right = node;
                        break;
                    } else {
                        current = current.right;
                    }
                }
            }
            return true;
        };

        Tree.prototype.search = function (value) {
            let current = this.root;
            while (current !== null) {
                console.log(current.value);
                if (value === current.value) {
                    console.log('get!');
                    return true;
                }
                current = value > current.value ? current.right : current.left;
            }
            console.log('cannot find!');
            return false;
        };

        Tree.prototype.preOrderTraverse = function (node) {
            if (node) {
                console.log(node.value);
                this.preOrderTraverse(node.left);
                this.preOrderTraverse(node.right);
            }
        };

        // test code
        let tree = new Tree();
        let dataList = [7, 8, 10, 9, 3, 12, 11, 4, 5, 1, 3];
        console.log(Array.isArray(dataList));
        dataList.forEach(function (data) {
            tree.insert(data);
        });
        tree.preOrderTraverse(tree.root);
    </script>

</head>
<body>

</body>
</html>